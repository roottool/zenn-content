---
title: "FormDataを「解釈する前」に立ち止まるという設計 -- safe-formdataの紹介"
emoji: "📝"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["typescript", "formdata"]
published: false
---

## 導入：見えている前提への疑問

多くのアプリケーションでは、FormDataは「意味のある入力」として自然に扱われています。

しかし、その意味はどこで保証されているのでしょうか。
本当にアプリケーション内部で解釈してよい入力なのかを、FormDataの段階で明示的に確認しているコードは多くありません。

問題は危険な実装があることではなく、前提が暗黙になっていることにあります。

## FormDataは「意味」を持たない

FormDataは、HTTPリクエストから得られるキーと値の集合にすぎません。

- ネスト構造はない
- 配列という概念もない
- オブジェクトでもない

それにもかかわらず、多くのアプリケーションではFormDataが構造を持つものとして扱われています。
これはFormDataに構造があるのではなく、構造が「読み取られている」だけです。
この「読み取り」は便利です。ですが同時に、アプリケーションにとって新しい前提を持ち込みます。

## 実際に起きた事故（CVE 実例）

この前提が問題になるのは、理論上の話だけではありません。

### tRPCの事例

tRPCではFormDataのキー名を解釈して構造を作る過程で、意図しない解釈の余地が生まれました。[^1]

問題だったのは特殊な攻撃手法ではなく、「安全な形になっているはずだ」という前提がコードのどこにも明示されていなかったことでした。

### superformsの事例

superformsでもフォーム処理を抽象化する過程で、入力の前提条件がフレームワーク内部に隠れました。[^2]

利用者のコードからは、どこで安全性が担保されているのかを判断しにくい構造になっていました。

---

<!-- textlint-disable -->
:::details form-dataで起きた別系統の事例
ここで挙げる事例は、FormDataの解釈が原因で起きた事故ではありません。
入力境界が曖昧なまま機能拡張された結果、問題が顕在化した例です。

境界が明示されないまま入力を扱ったことで、想定外の解釈が可能になる余地が生まれていました。[^3]
この事例は特定の実装ミスというよりも、「どこで安全性を判断するのか」が設計上不明確だったことに起因しています。
<!-- textlint-enable -->
:::

## 何が共通していたのか

前章で紹介した事例は個別の欠陥ではなく、境界を明示しない設計が積み重なった結果と見る方が自然です。
これらの事例に共通しているのは、設計の視点で見ると驚くほど単純な3点です。

- 解釈が暗黙に行われていた
- 入力境界が明確でなかった
- 「解釈してよいか」を問う段階が存在しなかった

多くのコードでは**どう解釈するか**は考えられていても、**解釈してよいか**は問われていませんでした。
「解釈する前」という段階が欠けています。

## 境界でやるべきこと

アプリケーションの境界で行うべきなのは、入力を理解することではありません。

- 意味を推測しない
- 曖昧さを解消しない
- 便利な形に直さない

境界の役割は、ただ一つしかありません。
それは「**この入力を、内部で解釈してよいかを判定すること**」です。

境界で意味を与えると、その意味が境界の内側で固定されます。
固定化された意味は前提となり、内部ロジックに引き継がれていきます。

## safe-formdataは何をするライブラリか

safe-formdataは、FormDataを便利に扱うためのライブラリではありません。
safe-formdataは、FormDataを**アプリケーション内部で解釈してよい入力かどうか**を判定するためのライブラリです。

このライブラリはFormDataを変換しません。

- オブジェクトにしない
- 配列にしない
- 型を付けない
- 意味を与えない

代わりに、次の一点だけを行います。

- このFormDataを、アプリケーション内部で解釈しても安全か

safe-formdataは、FormDataを「使いやすくする」のではなく、使ってよいかを判断する検問所として設計されています。

### リンク

@[card](https://github.com/roottool/safe-formdata)
@[card](https://www.npmjs.com/package/safe-formdata)

## なぜsafe-formdataは自動修復しないのか

危険なFormDataを検出しても、safe-formdataはそれを安全な形に修復しません。
これは制約ではなく意図的な設計判断です。
修復された入力は「安全に解釈できる入力」ではなく、「解釈された結果」だからです。

境界の役割は「**理解することではなく、通してよいかを決めること**」です。

## 他のライブラリと競合しない理由

safe-formdataは既存のパーサーやバリデーターと競合しません。
役割が異なるからです。

1. 入力が到達する
2. 解釈してよいかを判定する（safe-formdata）
3. 解釈する（パーサー・フレームワーク）
4. 正しいか検証する（バリデーター）

safe-formdataは、この中の2だけを担当します。

重要なのはどのライブラリを使うかではなく、順序を意識することです。
この順序を崩さないことが、境界を設計するということです。

## 向いているケース / 向いていないケース

safe-formdataは立ち止まることを要求するライブラリです。
立ち止まることを要求するので、使用に向いているケースと向いていないケースがあります。

### 向いているケース

- 入力境界を明示したい
- 暗黙の前提をコードに持ち込みたくない
- セキュリティを設計で担保したい

### 向いていないケース

- すぐに扱える便利さを最優先したい
- 自動変換・自動修復を期待している

## まとめ：解釈する前に立ち止まる

FormDataが危険なのではありません。
危険なのは、意味が保証されていない入力に意味を与えてしまうことです。

> 解釈する前に、それを解釈してよいかを確認する。

その一段を、コードとして明示するためのライブラリです。

---

[^1]: [CVE-2025-68130](https://github.com/advisories/GHSA-43p4-m455-4f4j)
[^2]: [CVE-2025-62381](https://github.com/advisories/GHSA-hwmc-4c8j-xxj7)
[^3]: [CVE-2025-7783](https://github.com/advisories/GHSA-fjxv-7rqg-78g4)
