---
title: "FormDataを「解釈する前」に立ち止まるという設計 -- safe-formdataの紹介"
emoji: "📝"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["typescript", "formdata"]
published: false
---

## 導入：見えている前提への疑問

多くのアプリケーションでは、FormDataは「意味のある入力」として自然に扱われています。

しかし、その意味はどこで保証されているのでしょうか。
FormDataが本当に、アプリケーション内部で解釈してよい入力なのかを、明示的に確認しているコードは多くありません。

問題は、危険な実装があることではなく、前提が暗黙になっていることにあります。

## FormDataは「意味」を持たない

FormDataは、HTTPリクエストから得られるキーと値の集合にすぎません。

- ネスト構造はない
- 配列という概念もない
- オブジェクトでもない

それにもかかわらず、多くのアプリケーションではFormDataが構造を持っているかのように扱われています。
これは、FormDataに構造があるのではなく、構造が読み取られているだけです。
この「読み取り」は便利ですが、同時に、アプリケーションにとって新しい前提を持ち込みます。

## 実際に起きた事故（CVE 実例）

この前提が問題になるのは、理論上の話だけではありません。

### tRPCの事例

tRPCではFormData由来の入力を一定の前提のもとで扱った結果、意図しない解釈の余地が生まれました。

ここで問題だったのは、特殊な攻撃手法ではなく、「安全な形になっているはずだ」という暗黙の前提でした。

### superformsの事例

superformsでも、フォーム処理を抽象化する過程で、入力の前提条件がフレームワーク内部に隠れました。

結果として、利用者のコードからはどこで安全性が担保されているのか分かりにくい構造になっていました。

<!-- --- -->

<!-- :::details 補足：form-data周辺の事例 -->
<!-- form-data周辺でも入力境界が曖昧なまま機能拡張した結果、問題が顕在化した例があります。 -->
<!-- ::: -->

## 何が共通していたのか

前章で紹介した事例は個別の欠陥というより、境界を明示しない設計が積み重なった結果と見る方が自然です。
これらの事例に共通しているのは以下の3点です。

- 解釈が暗黙に行われていた
- 入力境界が明確でなかった
- 「解釈してよいか」を問う段階が存在しなかった

多くのコードでは**どう解釈するか**は考えられていても、**解釈してよいか**は問われていませんでした。
「解釈する前」という段階が欠けています。

## 境界でやるべきこと

アプリケーションの境界で行うべきなのは、入力を理解することではありません。

- 意味を推測しない
- 曖昧さを解消しない
- 便利な形に直さない

境界の役割は、ただ一つしかありません。
それは「**この入力を、内部で解釈してよいかを判定すること**」です。

境界で意味を与えてしまうと、与えた意味が境界の内側で固定されてしまいます。
固定化された意味が前提となり、前提となった意味は内部ロジックに引き継がれてしまいます。

## safe-formdataは何をするライブラリか

safe-formdataは、FormDataを便利に扱うためのライブラリではありません。
FormDataを解釈してよい入力かどうかを判定するためのライブラリです。
このライブラリは、FormDataを変換しません。

- オブジェクトにしない
- 配列にしない
- 型を付けない
- 意味を与えない

代わりに、次の一点だけを行います。

- このFormDataを、アプリケーション内部で解釈しても安全か

safe-formdataは、FormDataを「使いやすくする」のではなく、使ってよいかを判断する検問所として設計されています。

### リンク

- GitHub: <https://github.com/roottool/safe-formdata>
- npm: <https://www.npmjs.com/package/safe-formdata>

## なぜsafe-formdataは自動修復しないのか

safe-formdataは、危険なFormDataを検出しても、それを安全な形に修復しません。
これは制約ではなく、意図的な設計判断です。
入力を「直す」という行為は、意味を与えることと同義だからです。
境界での役割は「**理解することではなく、通してよいかを決めること**」です。
境界での親切さが内部の不確実性になることを避けるため、safe-formdataは修復しません。

## 他のライブラリと競合しない理由

safe-formdataは既存のパーサーやバリデーターと競合しません。
役割が異なるからです。

1. 入力が到達する
2. 解釈してよいかを判定する（safe-formdata）
3. 解釈する（パーサー・フレームワーク）
4. 正しいか検証する（バリデーター）

safe-formdataは、この中の2だけを担当します。

重要なのはどのライブラリを使うかではなく、順序を意識することです。
この順序を崩さないことが、境界を設計するということです。

## 向いているケース / 向いていないケース

safe-formdataは立ち止まることを要求するライブラリです。
立ち止まることを要求するので、使用に向いているケースと向いていないケースがあります。

### 向いているケース

- 入力境界を明示したい
- 暗黙の前提をコードに持ち込みたくない
- セキュリティを設計で担保したい

### 向いていないケース

- すぐに扱える便利さを最優先したい
- 自動変換・自動修復を期待している

## まとめ：解釈する前に立ち止まる

FormDataが危険なのではありません。
危険なのは、意味が保証されていない入力に意味を与えてしまうことです。

> 解釈する前に、それを解釈してよいかを確認する。

その一段を、コードとして明示するためのライブラリです。
